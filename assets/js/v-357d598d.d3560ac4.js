"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[196],{9720:(a,n)=>{n.c=(a,n)=>{const e=a.__vccOpts||a;for(const[a,s]of n)e[a]=s;return e}},2704:(a,n,e)=>{e.r(n),e.d(n,{comp:()=>b,data:()=>h});var s=e(3968);const i=(0,s.QD)("h2",{id:"双链笔记",tabindex:"-1"},[(0,s.QD)("a",{class:"header-anchor",href:"#双链笔记"},[(0,s.QD)("span",null,"双链笔记")])],-1),t=(0,s.QD)("p",null,"@KurokoZ 个人认为双链笔记的核心不是一个单纯跳转的链接，而是在于“引用”和思路的延续性。举几个场景： 一、待办清单和随笔记 待办清单是一个时序化的任务 list，一个任务可能来自一次会议记录、老板临时的发言、一个产品调研 等等，每一个任务背后的原始文档可以很复杂，但任务本身可以记录的很简洁，特别是多线程的任务处理，这样的溯源非常有用，最近同时跟 4 个项目，深有体会；Obsidian 的 MD 语法支持很美观的待办清单，很舒服。 二、书籍之间的联系 很多书中，作者会推荐其他的书，那么就可以在记录读书笔记的时候，直接创建对这些推荐书的引用（得益于 obsidian 的基于引用自动创建文件，而不是只能引用现有文档），又或者一个作者有很多著作、有博客、有公众号，那么就可以给这个作者建一个单独的文档作为主页，其他著作的笔记、博客的摘录都是单独的文档，形成完整体系。 三、跨软件，非 URL 的场景 我的大量 PDF 文档管理在 DEVONThink，obsidian 的链接语法支持直接引用到 DEVONThink 中的文档，需要是可直接通过 OB 激活 DT 快速打开目标文档",-1),l={href:"https://sspai.com/post/67619",target:"_blank",rel:"noopener noreferrer"},o={href:"https://sspai.com/post/72385",target:"_blank",rel:"noopener noreferrer"},r=(0,s.IL)('<p>暂时放弃 Obisidian，虽然能按条件罗列页面，但没有 Logseq 方便。<strong>如果后续要继续用，则尝试将日记分为 3 份，然后用 Dataview 整合在一起，在上面进行修改</strong>。</p><p>Obsidian 更习惯记录，日常 Task 由滴答管理，中期且不急的任务则由 Trello 管理。自带的看板功能需要建立笔记，不如 Trello 方便。</p><p>Day Planer 有 sm18 的 Plan 功能。</p><h2 id="插件" tabindex="-1"><a class="header-anchor" href="#插件"><span>插件</span></a></h2><p>部分插件不能自动更新，需要手动下载插件文件，然后粘贴到 <code>.obsidian/plugins</code> 对应文件夹内。</p><h3 id="dataview" tabindex="-1"><a class="header-anchor" href="#dataview"><span>Dataview</span></a></h3>',6),p={href:"https://blacksmithgu.github.io/obsidian-dataview/query/queries/",target:"_blank",rel:"noopener noreferrer"},u=(0,s.IL)('<div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># journals 文本下所有</span>\ndv.list<span class="token punctuation">(</span>dv.pages<span class="token punctuation">(</span><span class="token string">&#39;&quot;journals&quot;&#39;</span><span class="token punctuation">)</span>.file.lists.text<span class="token punctuation">)</span>\n\n\n<span class="token comment"># 指定区域不为空</span>\n.where<span class="token punctuation">(</span>t <span class="token operator">=</span><span class="token operator">&gt;</span> t<span class="token operator">!=</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>\n\n<span class="token comment"># 包含指定文字</span>\n.where<span class="token punctuation">(</span>t <span class="token operator">=</span><span class="token operator">&gt;</span> t.includes<span class="token punctuation">(</span><span class="token string">&quot;Logseq&quot;</span><span class="token punctuation">))</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="obsidian-query-language" tabindex="-1"><a class="header-anchor" href="#obsidian-query-language"><span>Obsidian Query Language</span></a></h3>',2),d={href:"https://github.com/jplattel/obsidian-query-language",target:"_blank",rel:"noopener noreferrer"},c=(0,s.IL)('<p>但整合出的是链接，并非如 Logseq 一样显示文件内容。想想有没办法，显示文件内容。</p><p>下列代码会抓取，journals 文件夹中包含「今日工作」或「xxxxxxx」的文件。</p><div class="language-oql line-numbers-mode" data-ext="oql" data-title="oql"><pre class="language-oql"><code>name: &#39;OR combination list of results&#39;\nquery: { $and: [{ &quot;path&quot;: &quot;&#39;journals/&quot;}, { $or: [{ &quot;content&quot;: &quot;&#39;今日工作&quot; }, { &quot;content&quot;: &quot;&#39;xxxxxxx&quot; }] }]}\ntemplate: &quot;list&quot;\nbadge: true\ndebug: true\nsort: &quot;title&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="easy-typing" tabindex="-1"><a class="header-anchor" href="#easy-typing"><span>Easy Typing</span></a></h3><p>Easy Typing 是一个 Obsidian 的书写体验增强插件，自动格式化书写，比如自动在中英文之间添加空格，英文首字母大写，标点与文本间智能空格。</p><p>不过双拼容易出错，需要开启「行模式」。</p>',6),g={},b=(0,e(9720).c)(g,[["render",function(a,n){const e=(0,s.E1)("ExternalLinkIcon");return(0,s.Wz)(),(0,s.An)("div",null,[i,t,(0,s.QD)("ul",null,[(0,s.QD)("li",null,[(0,s.QD)("p",null,[(0,s.QD)("a",l,[(0,s.mY)("Obsidian 新手系列之你不可不知的插件"),(0,s.K2)(e)])])]),(0,s.QD)("li",null,[(0,s.QD)("p",null,[(0,s.QD)("a",o,[(0,s.mY)("每日笔记、日程管理、工作复盘——这是我钻研出的 Obsidian 八般武艺"),(0,s.K2)(e)])])])]),r,(0,s.QD)("p",null,[(0,s.QD)("a",p,[(0,s.mY)("Dataview"),(0,s.K2)(e)]),(0,s.mY)(" 功能更强大，不过用法也复杂许多。")]),u,(0,s.QD)("p",null,[(0,s.QD)("a",d,[(0,s.mY)("Obsidian Query Language"),(0,s.K2)(e)]),(0,s.mY)(" 能使用 Query 语言，将符合条件的文件整合到一页。")]),c])}]]),h=JSON.parse('{"path":"/apps/mianfeiaigc/obsidian.html","title":"Obsidian","lang":"zh-CN","frontmatter":{"article":false,"title":"Obsidian","order":2,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"双链笔记","slug":"双链笔记","link":"#双链笔记","children":[]},{"level":2,"title":"插件","slug":"插件","link":"#插件","children":[{"level":3,"title":"Dataview","slug":"dataview","link":"#dataview","children":[]},{"level":3,"title":"Obsidian Query Language","slug":"obsidian-query-language","link":"#obsidian-query-language","children":[]},{"level":3,"title":"Easy Typing","slug":"easy-typing","link":"#easy-typing","children":[]}]}],"git":{"createdTime":1708006858000,"updatedTime":1708066280000,"contributors":[{"name":"wpengjie0214","email":"wpengjie0214@163.com","commits":3}]},"readingTime":{"minutes":2.66,"words":798},"filePathRelative":"apps/mianfeiaigc/obsidian.md","localizedDate":"2024年2月15日"}')}}]);